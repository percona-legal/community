<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Michael.Aboagye on Percona Community</title><link>https://percona.community/tags/michael.aboagye/</link><description>Recent content in Michael.Aboagye on Percona Community</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>© Percona Community. MySQL, InnoDB, MariaDB and MongoDB are trademarks of their respective owners.</copyright><lastBuildDate>Fri, 04 Dec 2020 20:26:50 +0000</lastBuildDate><atom:link href="https://percona.community/tags/michael.aboagye/index.xml" rel="self" type="application/rss+xml"/><item><title>Fixing Common PostgreSQL Performance Bottlenecks</title><link>https://percona.community/blog/2020-12-04-fixing-common-postgresql-performance-bottlenecks/</link><pubDate>Fri, 04 Dec 2020 20:26:50 +0000</pubDate><guid>https://percona.community/blog/2020-12-04-fixing-common-postgresql-performance-bottlenecks/</guid><description>Overview In this article, I look at how poorly designed sharding systems and replication systems in PostgreSQL affect query performance in high volume situations, and how to ensure data consistency across many servers. I also discuss how excessive vacuuming generates I/O traffic, and how connection pooling is used to improve transaction throughput by caching connections from clients. I also cover how insufficient memory could affect PostgreSQL performance. These are key problems I have encountered as a database consultant, and how I&amp;rsquo;ve overcome them.</description></item></channel></rss>